## day9~day11

### day 9

#### 内存管理

由于我们要查看内存容量, 而每次存入的时候都是先经过缓存, 所以我们需要先禁用缓存才能开始存数, 

```c
unsigned int memtest(unsigned int start, unsigned int end)
{
    char flg486 = 0;
    unsigned int eflg, cr0, i;
        /* 确认CPU是386还是486以上的 */
    eflg = io_load_eflags();
    eflg |= EFLAGS_AC_BIT; /* AC-bit = 1 */
    io_store_eflags(eflg);
    eflg = io_load_eflags();
    if ((eflg & EFLAGS_AC_BIT) != 0) { /* 如果是386，即使设定AC=1，AC的值还会自动回到0 */
    flg486 = 1;
    }
    eflg &= ~EFLAGS_AC_BIT; /* AC-bit = 0 */
    io_store_eflags(eflg);
    if (flg486 != 0) {
        cr0 = load_cr0();
        cr0 |= CR0_CACHE_DISABLE; /* 禁止缓存 */
        store_cr0(cr0);
    }
    i = memtest_sub(start, end);
    if (flg486 != 0) {
        cr0 = load_cr0();
        cr0 &= ~CR0_CACHE_DISABLE; /* 允许缓存 */
        store_cr0(cr0);
    }
    return i;
}
```

#### 内存检查

如果内存存在的话, 写入后再读出应该会和写入的内容一致. 所以, 我们可以通过写入一次, 读出一次, 如果内容相同再写入反转后的内容再读.  若两次都成功则说明此处内存存在. 最终找到无法写入的地方, 则找到了内存的尽头.

由于编译器会有优化, 所以我们只能通过写汇编来防止编译器优化掉原本的代码.

``` asm
_memtest_sub: ; (unsigned int start, unsigned int end)->unsigned int
		PUSH	EDI ; 需要使用这三个寄存器
		PUSH 	ESI
		PUSH 	EBX
		MOV		ESI, 0xAA55AA55 ; pat0 = 0xaa55aa55
		MOV 	EDI, 0x55AA55AA ; pat1 = 0x55aa55aa
		MOV 	EAX, [ESP+12+4] ; i = start
mts_loop:
		MOV 	EBX, EAX
		ADD 	EBX, 0xFFC		;p = i + 0xffc
		MOV		EDX, [EBX] 		;old = *p
		MOV 	[EBX], ESI 		;*p = pat0
		XOR 	DWORD [EBX], 0xFFFFFFFF ; *p^=0xffffffff
		CMP 	EDI, [EBX] 		; if(*p!=pat1) goto fin;
		JNE 	mts_fin
		XOR 	DWORD [EBX], 0xFFFFFFFF
		CMP 	ESI, [EBX] 		;if(*p != pat0) goto fin
		JNE 	mts_fin
		MOV 	[EBX], EDX 		;*p = old
		ADD 	EAX, 0x1000  	;i+=0x1000
		CMP 	EAX, [ESP+12+8]

		JBE 	mts_loop
		POP 	EBX
		POP 	ESI
		POP 	EDI
		RET
mts_fin:
		MOV 	[EBX], EDX 	 	;*p = old
		POP 	EBX
		POP 	ESI
		POP 	EDI
		RET
```

#### 内存分配与回收

此处逻辑比较简单, 通过创建一张可用表来实现内存管理. 

在分配内存时, 若某处可用且剩余空间大于所需空间, 则可以从该处获取内存, 若获取后该处剩余内存为0, 则删除此处节点, 并把其后节点向前移动一格.

回收内存时, 首先判断回收的起始地址是否为某个空余节点的终止地址, 若是则将两者连接; 再判断回收块的终止地址是否为下一节点的起始地址, 若是则将两者合并, 将下个节点之后的节点向前移动; 若都不是, 则首先将需要插入处后面的节点往后移动, 再将该回收块插入, 作为一个新节点, 更新表信息.

由于代码逻辑比较简单, 就不放了.

### day 10

#### 继续优化内存管理

为了防止碎片过多, 需要进行4k对齐

具体为`size = (size + 0xfff) & 0xfffff000`

#### 叠加图层



