## Day 03 ~ Day 05

### Day 03

#### 前期记录与操作

由于之前没记清楚各种缩写, 导致看代码的时候出现了点困难, 现在先记录一下容易忘记的东西.

-IPL: initial program loader 启动程序加载器

| pseudo-instructions | function               |
| ------------------- | ---------------------- |
| JC                  | jump if carry          |
| JNC                 | jump if not carry      |
| JE                  | jump if equal          |
| JAE                 | jump if above or equal |
| INT                 | interrupt              |

由于省略的情况下, DS会作为段寄存器, 例如`MOV CX,[1234]`，其实是`MOV CX,[DS:1234]`, 故必须预先指定其为0, 否则地址的值要加上这个数的16倍(寻址空间为1M). 

| 16-bit segment register | function      |
| ----------------------- | ------------- |
| ES                      | extra segment |
| CS                      | code segment  |
| SS                      | stack segment |
| DS                      | data segment  |

作者给出的IPL启动区(512字节)在C0H0S1(柱面0, 磁头0, 扇区1), 接下来要装载的是C0H0S2.

#### 导入c语言

由于c语言中没有HLT而作者又特别喜欢使用, 那么只能用汇编语言写一个, 按照作者的思路, 我们得先实现一个`naskfunc.nas`

```asm
; naskfunc
; TAB = 4
[FORMAT "WCOFF"]    ;制作目标文件的模式
[BITS 32]           ;制作32位机用的机器语言

[FILE "naskfunc.nas"]

    GLOBAL  _io_hlt  ;程序中包含的函数名


[SECTION .text]      ;目标文件先写这些再写程序

_io_hlt:             ; void _io_hlt(void);
    _io_hlt
    RET
```

汇编编写后的函数需要与bootpack.obj链接, 所以也需要编译成目标文件。因此将输出格式设定为WCOFF模式(google后仍不知道什么意思)。

需要链接的函数名，都要用GLOBAL指令声明, 且函数名前需要有‘_’.

#### batch 语法

可以看到在make.bat中的make.exe后有`%1 %2 …. %9`这些都是用来在调用make.bat并加上参数时, 传给make.exe的参数.

`del` `copy`均为batch命令, 顾名思义, 不多解释.

#### gcc 语法

- `-wall` : 显示警告
- `-Os`: 相当于`-O2.5`, 使用了所有O2的优化而不减少代码尺寸

### Day 4

#### 内存写入

为了在c语言添加可以写入内存地址的函数, 我们需要在nask

func.nas 中添加一个`_write_mem8`

#### 条纹图案

### 参考:

- [gcc中o0, o1, o2, o3 优化的区别](https://blog.csdn.net/qq_31108501/article/details/51842166)