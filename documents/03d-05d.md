## Day 03 ~ Day 05

### Day 03

#### 前期记录与操作

由于之前没记清楚各种缩写, 导致看代码的时候出现了点困难, 现在先记录一下容易忘记的东西.

-IPL: initial program loader 启动程序加载器

| pseudo-instructions | function               |
| ------------------- | ---------------------- |
| JC                  | jump if carry          |
| JNC                 | jump if not carry      |
| JE                  | jump if equal          |
| JAE                 | jump if above or equal |
| INT                 | interrupt              |

由于省略的情况下, DS会作为段寄存器, 例如`MOV CX,[1234]`，其实是`MOV CX,[DS:1234]`, 故必须预先指定其为0, 否则地址的值要加上这个数的16倍(寻址空间为1M). 

| 16-bit segment register | function      |
| ----------------------- | ------------- |
| ES                      | extra segment |
| CS                      | code segment  |
| SS                      | stack segment |
| DS                      | data segment  |

作者给出的IPL启动区(512字节)在C0H0S1(柱面0, 磁头0, 扇区1), 接下来要装载的是C0H0S2.

#### 导入c语言

由于c语言中没有HLT而作者又特别喜欢使用, 那么只能用汇编语言写一个, 按照作者的思路, 我们得先实现一个`naskfunc.nas`

```asm
; naskfunc
; TAB = 4
[FORMAT "WCOFF"]    ;制作目标文件的模式
[BITS 32]           ;制作32位机用的机器语言

[FILE "naskfunc.nas"]

    GLOBAL  _io_hlt  ;程序中包含的函数名


[SECTION .text]      ;目标文件先写这些再写程序

_io_hlt:             ; void _io_hlt(void);
    _io_hlt
    RET
```

汇编编写后的函数需要与bootpack.obj链接, 所以也需要编译成目标文件。因此将输出格式设定为WCOFF模式(google后仍不知道什么意思)。

需要链接的函数名，都要用GLOBAL指令声明, 且函数名前需要有‘_’.

#### batch 语法

可以看到在make.bat中的make.exe后有`%1 %2 …. %9`这些都是用来在调用make.bat并加上参数时, 传给make.exe的参数.

`del` `copy`均为batch命令, 顾名思义, 不多解释.

#### gcc 语法

- `-wall` : 显示警告
- `-Os`: 相当于`-O2.5`, 使用了所有O2的优化而不减少代码尺寸

### Day 4

#### 内存写入

为了在c语言添加可以写入内存地址的函数, 我们需要在nask

func.nas 中添加一个`_write_mem8`, 并将函数设为gloabal

```asm
_write_mem8: ;void _write_mem8(int addr, int data);
		MOV		ECX, [ESP+4]
		MOV		AL, [ESP+8]
		MOV		[ECX], AL
		RET
```

注意: 

1. 函数中的第一个参数地址为[ESP+4], 第二个为[ESP+8], 第三个为[ESP +12]…
2. 由于我们的系统已经是32位, 所以不要使用16位的寄存器
3. 能自由使用的寄存器只有EAX, ECX和EDX, 由于c语言会用到其他寄存器, 故其他的只能读不能写.
4. naskfunc.nas 中还添加了一个 INSTRSET 指令, 告诉nasm本程序是给486cpu使用.



#### 条纹图案

真够亮的

![1551706930591](assets/1551706930591.png)

### 指针

C语言中, 类型与保留字有以下的匹配:

- char : BYTE类
- short : WORD类
- int : DWORD类

可以通过char指针来直接给8位地址赋值

#### 色号设定

1. 定义`init_palette`函数, 用于初始化调色板

   1. 按照rgb的值写入一个**unsigned char**数组中, 防止0xff被误认为是-1的补码

2. 在汇编中加入用于io的函数

   - io_load_eflags: 记录中断许可标志的值
   - io_cli: 置中断许可标志为0, 禁止中断
   - io_store_eflags(eflags): 复原中断许可标志

   其中伪指令CLI是clear interrupt flag, 即interrupt flag 置0

   EFLAGS寄存器如图所示:

   ![1551759657057](assets/1551759657057.png)

   汇编中需要说明两个函数:

   ```asm
   ;先将EFLAGS压入栈中, 然后pop出并送给EAX
   _io_load_eflags:	; int io_load_eflags(void);
   		PUSHFD 		; means PUSH EFLAGS
   		POP		EAX
   		RET
   
   ;先将 eflags 压入栈中, 然后再push给EFLAGS
   _io_store_eflags:	; void _io_store_eflags(int eflags)
   		MOV		EAX, [ESP+4]
   		PUSH 	EAX
   		POPFD
   		RET
   ```

   

   #### 绘制矩形和绘制界面

   ![1551771918641](assets/1551771918641.png)

   这里只是简单的代码重复, 不再描述

   ### Day 5

   #### 接受启动信息

   在 bootpack.c里面的地址值和像素值应该从asmhead.nas里面获取, 我们可以构造一个结构体来保存这些数值, 书中写的很详细, 不多描述.

   ```c
   struct BOOTINFO {
       char cyls, leds, vmode, reserve;
       short scrnx, scrny;
       char *vram;
   };
   // 0x0ff0是引导扇区地址
    struct BOOTINFO *binfo = (struct BOOTINFO *)0x0ff0
   ```

   #### 显示字符

   函数如下, 得到所需字符指针font后, 将相应的像素变为目的颜色c. 

   ```c
   void putfont8(char *vram, int xsize, int x, int y, char c, char *font)
   {
       int i;
       char *p, d /* data */;
       for (i = 0; i < 16; i++) {
           p = vram + (y + i) * xsize + x;
           d = font[i];
           if ((d & 0x80) != 0) {
               p[0] = c;
           }
           if ((d & 0x40) != 0) {
               p[1] = c;
           }
           if ((d & 0x20) != 0) {
               p[2] = c;
           }
           if ((d & 0x10) != 0) {
               p[3] = c;
           }
           if ((d & 0x08) != 0) {
               p[4] = c;
           }
           if ((d & 0x04) != 0) {
               p[5] = c;
           }
           if ((d & 0x02) != 0) {
               p[6] = c;
           }
           if ((d & 0x01) != 0) {
               p[7] = c;
           }
       }
       return;
   }
   ```

   #### 链接字符库

   首先利用makefont工具将txt编译为bin文件, 再将bin转化为obj, 并得到一个名为‘hankaku'的量, 我们需要在makefile中做出如下改变

   ```makefile
   #需要添加的
   MAKEFONT = $(TOOLPATH)makefont.exe
   BIN2OBJ  = $(TOOLPATH)bin2obj.exe
   
   hankaku.bin : hankaku.txt Makefile
   	$(MAKEFONT) harkaku.txt hankaku.bin
   
   hankaku.obj : hankaku.bin Makefile
   	$(BIN2OBJ) hankaku.bin hankaku.obj _hankaku
   	
   #需要变动的
   --
   bootpack.bim : bootpack.obj naskfunc.obj Makefile
   	$(OBJ2BIM) @$(RULEFILE) out:bootpack.bim stack:3136k map:bootpack.map bootpack.obj naskfunc.obj
   
   ++
   bootpack.bim : bootpack.obj naskfunc.obj hankaku.obj Makefile
   	$(OBJ2BIM) @$(RULEFILE) out:bootpack.bim stack:3136k map:bootpack.map bootpack.obj naskfunc.obj hankaku.obj
   ```

   

   #### 显示字符串

   在得到hankaku数组后, 利用putfont函数实现输出字符串

   ```c
   void putfonts8_asc(char *vram, int xsize, int x, int y, char c,
                      unsigned char *s)
   {
       extern char hankaku[4096];
       for (; *s != 0x00; s++) {
           putfont8(vram, xsize, x, y, c, hankaku + *s * 16);
           x += 8;
       }
       return;
   }
   ```

   

   






### 参考:

- [gcc中o0, o1, o2, o3 优化的区别](https://blog.csdn.net/qq_31108501/article/details/51842166)