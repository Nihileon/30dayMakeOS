## Day 6 - 8

### Day 06: 分割编译与中断处理

#### 整理makefile

``` makefile
%.gas : %.c Makefile
	$(CC1) -o $*.gas $*.c

%.nas : %.gas Makefile
	$(GAS2NASK) $*.gas $*.nas

%.obj : %.nas Makefile
	$(NASK) $*.nas $*.obj $*.lst
```

使用预定义变量进行匹配 

其中makefile的预定义变量及其含义如下:

```makefile
$* 
不包含扩展名的目标文件名称。 

$+ 
所有的依赖文件，以空格分开，并以出现的先后为序，可能包含重复的依赖文件。 

$< 
第一个依赖文件的名称。 

$? 
所有的依赖文件，以空格分开，这些依赖文件的修改日期比目标的创建日期晚。 

$@ 
目标的完整名称。 

$^ 
所有的依赖文件，以空格分开，不包含重复的依赖文件。 

$% 
如果目标是归档成员，则该变量表示目标的归档成员名称。例如，如果目标名称为 
mytarget.so(image.o)，则 $@ 为 mytarget.so，而 $% 为 image.o。 
```

​	

#### load_gdtr 详解

``` asm
_load_gdtr: ; void load_gdtr(int limit, int addr);
MOV AX,[ESP+4] ; limit
MOV [ESP+6],AX
LGDT [ESP+6]
RET
```

由于我们的GDTR只有48位, 其中低16位为段上限, 高32位为基址, 而对于我们的第一个参数[ESP+4] 为段上限, 应该放在段上限, 

```asm
在传入的时候, 若limit为0x0000ffff, addr为0x00270000, 他们的存放如下
esp     esp+4       esp+8
| ffff0000 | 00002700 |
一个数的低位放在内存的低地址上

MOV		AX,[ESP+4]
| ffff0000 | -> AX

MOV		[ESP+6],AX
| ffff | 0000 | 0000 | 2700 | -> | ffff | ffff | 0000 | 2700 |

LGDT	[ESP+6]
| ffff | 0000 | 2700 | -> GDT
在GDTR中存放的数是0x00270000ffff, 可以看到总算跟标准的GDTR吻合了
```

#### 继续解释gdt

在GDT中, 段上限是4GB, 而limit只有20位,  这是因为在GDT中有一个标志位Gbit, 如果这个标志为1, 那么limit里面一个单位是1个page(4KB)

![img](assets/20141001142133171)

GDT的47~40, 55~52位是一共12位的段属性

由于55~40中还存有limit的高4位, 所以机器需要把属性作为16位来处理 : xxxx0000xxxxxxxx

##### 高4位

"ar的高4位被称为“扩展访问权”。为什么这么说呢？因为这高4位的访问属性在80286的时代
还不存在，到386以后才可以使用。这4位是由“GD00”构成的，其中G是指刚才所说的G bit，D
是指段的模式，1是指32位模式，0是指16位模式。这里出现的16位模式主要只用于运行80286的
程序，不能用于调用BIOS。所以，除了运行80286程序以外，通常都使用D=1的模式。"

##### 低8位

00000000（0x00）：未使用的记录表（descriptor table）。
10010010（0x92）：系统专用，可读写的段。不可执行。
10011010（0x9a）：系统专用，可执行的段。可读不可写。
11110010（0xf2）：应用程序用，可读写的段。不可执行。
11111010（0xfa）：应用程序用，可执行的段。可读不可写。

而我们在上次(day3-5)的文档已经解释过这八位的意义, 不再重复.

为了保护GDT, 当程序处于应用模式时不被允许修改GDT

CPU到底是处于系统模式还是应用模式，取决于执行中的应用程序是位于访问权为0x9a的
段，还是位于访问权为0xfa的段。

#### 初始化PIC (programmable interrupt controller) 

![1552204032064](assets/1552204032064.png)

#### pic寄存器介绍

pic中的寄存器全是8位

- IMR(interrupt mask register) : 

  - 8位分别对应8路IRQ信号
  - 如果某一位为1, 那么该位对应的IRQ被屏蔽

- ICW(initial control word) :

  -  word的意思在不同机器上不一样, 可能为16bit 也可能为32bit 

  - ICW共有4个

    - ICW1和ICW4与主板配线和中断信号电器特性相关
    - ICW3: "是有关主从连接的设定, 对主PIC而言，第几号IRQ与从PIC相连，是用8位来设定的。
      如果把这些位全部设为1，那么主PIC就能驱动8个从PIC,但我们所用的电脑并不是这样的，所以就设定成00000100" , 而由于需要硬件与软件一致, ICW3也是不可以修改的.
    - ICW2: ICW2可以决定IRQ用哪一号中断通知cpu:
      - 当中断发生后, CPU命令pic发送两个字节(0xcd 0x??), 由于电路原因, 对于cpu来说从pic读入的2字节数据与从内存读入是一样的, 故cpu把送过来的数据以机器指令执行. 
        - 0xcd是INT
        - 0x??是int号

    这次是以INT 0x20\~0x2f接收中断信号IRQ0~15而设定的, 而0x00-0x0f 是用于cpu的保护系统通知, 两者不可重复.



#### 中断处理程序制作

鼠标是IRQ12，键盘是IRQ1，所以我们编写了用于INT 0x2c和INT 0x21的中断处理程序（handler）

##### 对PUSH和 POP的解释

`PUSH EAX` 相当于

```asm
ADD ESP,-4 ;esp减去4, 所得值作为地址, 将寄存器的值保存到这个地址对应的内存中
MOV [SS:ESP],EAX
```

而`POP EAX` 则相当于

```asm
MOV EAX,[SS:ESP] ; SS是栈段寄存器, 与ESP配合使用
ADD ESP,4
```

`PUSHAD`相当于

```asm
PUSH EAX
PUSH ECX
PUSH EDX
PUSH EBX
PUSH ESP
PUSH EBP
PUSH ESI
PUSH EDI
;按顺序执行这些操作
;而POPAD则刚好反过来, 从EDI开始一个个POP
```

##### 对于_asm_inthandler()的解释

``` asm
_asm_inthandler21: ; 在中断前保存寄存器状态, 并将ES和DS设为与SS值相同 并在中断后恢复寄存器
		PUSH	ES
		PUSH	DS
		PUSHAD
		MOV		EAX,ESP
		PUSH	EAX
		MOV		AX,SS
		MOV		DS,AX
		MOV		ES,AX
		CALL	_inthandler21
		POP		EAX
		POPAD
		POP		DS
		POP		ES
		IRETD
```

"关于在DS和ES中放入SS值的部分，因为C语言自以为是地认为“DS也好，ES也好，SS也好，它们都是指同一个段”，所以如果不按照它的想法设定的话，函数inthandler21就不能顺利执行"

#### 初始化IDT

```c
/* IDT的设定 */
set_gatedesc(idt + 0x21, (int) asm_inthandler21, 2 << 3, AR_INTGATE32);
set_gatedesc(idt + 0x2c, (int) asm_inthandler2c, 2 << 3, AR_INTGATE32);
```

这里的2 << 3 的2是指在第二段, 左移三位是因为最低三位有其他用途.

而这个号为2的段在前面的代码有说明: `set_segmdesc(gdt + 2, LIMIT_BOTPAK, ADR_BOTPAK, AR_CODE32_ER);`正好覆盖了整个bootpack.hrb

### Day 07

#### 获取键盘编码

修改int.c中的inthandler21

```c
io_out8(PIC0_OCW2, 0x61); /* 通知PIC"IRQ-01已经受理完毕" */
data = io_in8(PORT_KEYDAT);
sprintf(s, "%02X", data);
boxfill8(binfo->vram, binfo->scrnx, COL8_008484, 0, 16, 15, 31);
putfonts8_asc(binfo->vram, binfo->scrnx, 0, 16, COL8_FFFFFF, s);
```

将“0x60+IRQ号码”输出给OCW2即通知PIC中断已发生, 让PIC继续监视中断

#### 加快中断

```C
 if (keybuf.flag == 0) {
            io_stihlt();
        } else {
            i = keybuf.data;
            keybuf.flag = 0;
            io_sti();
 			// ...
 }
//在HariMain里使用io_stihlt()而不是先使用sti再使用hlt是因为
```

机器语言的STI指令之后，如果紧跟着HLT指令，那么就暂不受理这两条指令之间的中断，而要等到HLT指令之后才受理，所以使用io_stihlt函数就能克服这一问题

#### 制作FIFO缓冲区

#### 接受鼠标中断

鼠标为IRQ12, 需要控制电路先有效, 鼠标本身才能有效, 而鼠标控制电路包含在键盘控制电路中, 故我们需要等待键盘控制电路有效(`void wait_KBC_sendready(void)`).

初始化键盘:

```c
void init_keyboard(void)
{
/* 初始化键盘控制电路 */
wait_KBC_sendready();
io_out8(PORT_KEYCMD, KEYCMD_WRITE_MODE);
wait_KBC_sendready();
io_out8(PORT_KEYDAT, KBC_MODE);
return;
}
```

#### 接受鼠标数据

IRQ-12是从PIC的第4号, 先要通知IRQ12受理完成再通知主PIC, 因为主从协调不能自动完成, 如果不告诉主PIC怎么做的话会忽略PIC的下一个中断请求

```c
void inthandler2c(int *esp)
    /* 来自PS/2鼠标的中断 */
{
unsigned char data;
io_out8(PIC1_OCW2, 0x64); /* 通知PIC1 IRQ-12的受理已经完成 */
io_out8(PIC0_OCW2, 0x62); /* 通知PIC0 IRQ-02的受理已经完成 */
data = io_in8(PORT_KEYDAT);
fifo8_put(&mousefifo, data);
return;
}
```

### Day 08

#### 鼠标的显示

首先我们了解到鼠标每次会给出三个字节的信息, 我们需要在等待鼠标准备完毕后依次读取三个字节

读取的三个字节如"08 12 34", 

- 如果移动鼠标, 这个08部分的‘0’ 会在0-3中变化,  
- 8那一位只在点击时有变化, 变化范围为8-f
- 12 部分与鼠标左右移动有关
- 34 部分与鼠标上下移动有关

解码如下

```c
int mouse_decode(struct MOUSE_DEC *mdec, unsigned char dat)
{
    switch (mdec->phase) {
    case 0:
        //收到激活指令
        if (dat == 0xfa) {
            mdec->phase = 1;
        }
        return 0;
    case 1:
        // dat & 11001000 == 00001000
        if ((dat & 0xc8) == 0x08) { 
            mdec->buf[0] = dat;
            mdec->phase = 2;
        }
        return 0;
    case 2:
        mdec->buf[1] = dat;
        mdec->phase = 3;
        return 0;
    case 3:
        mdec->buf[2] = dat;
        mdec->phase = 1;
        mdec->btn = mdec->buf[0] & 0x07; // buf[0] & 00000111 左右中键是buf[0]的后三位
        mdec->x = mdec->buf[1];
        mdec->y = mdec->buf[2];
        if ((mdec->buf[0] & 0x10) != 0) { //00010000
            mdec->x |= 0xffffff00; //将第八位以后设为全1或全0都可以, 由于难以设为全0, 故这里设为全1
        }
        if ((mdec->buf[0] & 0x20) != 0) { //00100000
            mdec->y |= 0xffffff00;
        }
        mdec->y = -mdec->y; // 鼠标移动方向与y轴相反
        return 1;
    default:
        return -1;
    }
}
```

#### 

#### 进入32位保护模式

首先我们可以看到作者设定的地址空间如下:

0x00000000 - 0x000fffff : 虽然在启动中会多次使用，但之后就变空。（1MB）
0x00100000 - 0x00267fff : 用于保存软盘的内容。（1440KB）
0x00268000 - 0x0026f7ff : 空（30KB）
0x0026f800 - 0x0026ffff : IDT （2KB）
0x00270000 - 0x0027ffff : GDT （64KB）
0x00280000 - 0x002fffff : bootpack.hrb（512KB）
0x00300000 - 0x003fffff : 栈及其他（1MB）
0x00400000 - : 空

```asm
; haribote-os boot asm
; TAB=4

BOTPAK	EQU		0x00280000		; 加载bootpack
DSKCAC	EQU		0x00100000		; 磁盘缓存的位置
DSKCAC0	EQU		0x00008000		; 磁盘缓存的位置（实模式）

; BOOT_INFO相关
CYLS	EQU		0x0ff0			; 引导扇区设置
LEDS	EQU		0x0ff1
VMODE	EQU		0x0ff2			; 关于颜色的信息
SCRNX	EQU		0x0ff4			; 分辨率X
SCRNY	EQU		0x0ff6			; 分辨率Y
VRAM	EQU		0x0ff8			; 图像缓冲区的起始地址

		ORG		0xc200			;  这个的程序要被装载的内存地址

; 画面設定

		MOV		AL,0x13			; VGA显卡，320x200x8bit
		MOV		AH,0x00
		INT		0x10
		MOV		BYTE [VMODE],8	; 屏幕的模式（参考C语言的引用）
		MOV		WORD [SCRNX],320
		MOV		WORD [SCRNY],200
		MOV		DWORD [VRAM],0x000a0000

; 通过BIOS获取指示灯状态

		MOV		AH,0x02
		INT		0x16 			; keyboard BIOS
		MOV		[LEDS],AL

; 防止PIC接受所有中断
;	AT兼容机的规范、PIC初始化
;	然后之前在CLI不做任何事就挂起
;	PIC在同意后初始化

; io_out(PIC0_IMR, 0XFF);
; io_out(PIC1_IMR, 0XFF);
		MOV		AL,0xff
		OUT		0x21,AL
		NOP						; 不断执行OUT指令
		OUT		0xa1,AL

; io_cli();
		CLI						; 进一步中断CPU


; 设置A20GATE信号线为ON, 作用是使得内存1MB以上部分可用
; #define KEYCMD_WRITE_OUTPORT 0XD1
; #define KBC_OUTPORT_A20G_ENABLE 0XDF
; wait_KBC_sendready();
		CALL	waitkbdout
; io_out8(PORT_KEYCMD, KEYCMD_WRITE_OUTPORT);
		MOV		AL,0xd1
		OUT		0x64,AL
; wait_KBC_sendready();
		CALL	waitkbdout
; io_out8(PORT_KEYDAT, KBC_OUTPORT_A20G_ENABLE);
		MOV		AL,0xdf			; enable A20
		OUT		0x60,AL
; wait_KBC_sendready();    这句话是为了等待指令执行完成
		CALL	waitkbdout

; 保护模式转换

[INSTRSET "i486p"]				; 为了能使用386之后的LGDT, EAX, CR0等关键字

		LGDT	[GDTR0]			; 设置临时GDT
		MOV		EAX,CR0
		AND		EAX,0x7fffffff	; 设bit31为0（禁用分页）
		OR		EAX,0x00000001	; 设bit0为1 (切换到保护模式)
		MOV		CR0,EAX
		; 由于cpu使用管道进行流水处理,
		; 所以当我们切换为32位模式改变了指令的时候需要重新解释一遍
		JMP		pipelineflush
; 除CS以外的所有段寄存器值都变为了0x0008, 相当于gdt+1的段
; 而CS不变是因为防止发生混乱
pipelineflush:
		MOV		AX,1*8			;  写32bit的段
		MOV		DS,AX
		MOV		ES,AX
		MOV		FS,AX
		MOV		GS,AX
		MOV		SS,AX

; bootpack传递
; memcpy(bootpack, BOTPAK, 512*1024/4)
		MOV		ESI,bootpack	; 源
		MOV		EDI,BOTPAK		; 目标
		MOV		ECX,512*1024/4  ; 大小
		CALL	memcpy

; 传输磁盘数据

; 从引导区开始
; memcpy(0x7c00, DSKCAC, 512/4)
; DSKCAC是0x00100000，这句意思是从0x7c00复制512Byte到0x00100000
		MOV		ESI,0x7c00		; 源
		MOV		EDI,DSKCAC		; 目标
		MOV		ECX,512/4
		CALL	memcpy

; 剩余的全部
; 意思就是将始于0x00008200的磁盘内容，复制到0x00100200那里
;memcpy(DSKCAC0+512, DSKCAC+512, CYLS*512*18*2/4)
		MOV		ESI,DSKCAC0+512	; 源
		MOV		EDI,DSKCAC+512	; 目标
		MOV		ECX,0
		MOV		CL,BYTE [CYLS] 	;CYLS是柱面
		IMUL	ECX,512*18*2/4	; 除以4得到字节数
		SUB		ECX,512/4		; IPL偏移量
		CALL	memcpy

; 由于还需要asmhead才能完成
; 完成其余的bootpack任务

; bootpack启动
; 同样是memcpy
; 会将bootpack.hrb第0x10c8字节开始的0x11a8字节复制到0x00310000号地址去
		MOV		EBX,BOTPAK
		MOV		ECX,[EBX+16]	;[EBX+16]:bootpack.hrb之后的第16号地址。值是0x11a8
		ADD		ECX,3			; ECX += 3;
		SHR		ECX,2			; 右移指令, ECX /= 4;
		JZ		skip			; 没有需要转送的东西时
		MOV		ESI,[EBX+20]	; 源 0x10c8
		ADD		ESI,EBX
		MOV		EDI,[EBX+12]	; 目标 0x00310000
		CALL	memcpy
skip:
		MOV		ESP,[EBX+12]	; 堆栈的初始化, 将0x310000代入到ESP
		JMP		DWORD 2*8:0x0000001b ; 将2 * 8 代入到CS里，同时移动到第二个段的0x1b号地址,
		;第2个段的基地址是0x280000，所以实际上是从0x28001b开始执行的。这也就是bootpack.hrb的0x1b号地址

waitkbdout:
		IN		AL,0x64 		; 空读, 从设备号0x64读取数据
		AND		AL,0x02
		IN 		AL,0x60			; 空读, 从设备号0x60读取数据
		JNZ		waitkbdout		; AND结果不为0跳转到waitkbdout
		RET

memcpy:
		MOV		EAX,[ESI]
		ADD		ESI,4
		MOV		[EDI],EAX
		ADD		EDI,4
		SUB		ECX,1
		JNZ		memcpy			; 运算结果不为0跳转到memcpy
		RET
; memcpy地址前缀大小

		ALIGNB	16				;，一直添加DBO，直到时机合适的时候为止, 即能整除16为止
; GDT0也是一种特定的GDT, 0号为空区域
GDT0:
		RESB	8				; 空区域
		; set_segmdesc(gdt + 1, 0xffffffff, 0x00000000, AR_DATA32_RW);
		DW		0xffff,0x0000,0x9200,0x00cf	; 可以读写的段（segment）32bit
		; set_segmdesc(gdt + 2, LIMIT_BOTPAK, ADR_BOTPAK, AR_CODE32_ER);
		DW		0xffff,0x0000,0x9a28,0x0047	; 可执行的文件的32bit寄存器（bootpack用）


		DW		0
; 相当于LGDT指令, 通知GDT0有GDT存在, 在GDT0里，写入了16位的段上限，和32位的段起始地址
GDTR0:
		DW		8*3-1
		DD		GDT0

		ALIGNB	16
bootpack:

```

最初状态时，GDT在asmhead.nas里，而不在0x00270000 ~ 0x0027ffff的范围里, IDT也并未设置, 处于中断禁止状态, 需要尽快开放中断, 所以在HariMain里, 应该在palette初始化前先重新创建GDT和IDT, 初始化PIC, 并执行io_sti()

 